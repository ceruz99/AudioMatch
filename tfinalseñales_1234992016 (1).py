# -*- coding: utf-8 -*-
"""TFinalSeñales_1234992016.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/107vxqiJ2xcV0_YS_aqnaqoEHlMwyVwky
"""

#Librerias
import numpy as np
import matplotlib.pyplot as plt
import librosa
import librosa.display
from scipy.stats import pearsonr
from scipy.io import wavfile
from IPython.display import Audio
from scipy.spatial.distance import euclidean
from re import I
import seaborn as sns
import soundfile as sf

# Parámetros
sr = 48000  # Frecuencia de muestreo
n_fft = 8192  # Tamaño de la ventana FFT
hop_length = 2048  # Tamaño del salto
n_mels = 128  # Número de bandas Mel
n_mfcc =15 # Número de coeficientes MFCC deseados
# Rango de SNR en dB
snr_range = list(range(-20, 1))  # SNRdB ∈ [−20, −19, ..., 0]

#Funciones
def generar_audio_vector(path_audio):

    # Cargar el archivo de audio usando la ruta proporcionada
    if isinstance(path_audio, str):
      fs, datos = wavfile.read(path_audio)
      duracion_a_recortar = 30  # Duración en segundos
      num_muestras_recortar = int(duracion_a_recortar * fs)
      tiempo = np.linspace(0,len(datos)/fs,num=len(datos))

      datos_recortados = datos[:num_muestras_recortar]
      tiempo_recortado = tiempo[:num_muestras_recortar]
      #Normalizamos el audio en amplitud, que la señal tenga valores entre -1 y 1
      x_norm_recortado = (datos_recortados-np.mean(datos_recortados))/float(np.max(np.abs(datos_recortados)))
      canal_izquierdo = x_norm_recortado[:, 0]

      # 1. Ventaneo y FFT
      mel_spectrogram = librosa.feature.melspectrogram(
          y=canal_izquierdo, sr=sr, n_fft=n_fft, hop_length=hop_length, n_mels=n_mels,window='hann')

      # 2. Escala logarítmica (dB)
      log_mel_spectrogram = librosa.power_to_db(mel_spectrogram, ref=np.max)

      # 3. Cálculo de MFCCs
      audio_matriz = librosa.feature.mfcc(S=log_mel_spectrogram, sr=sr, n_mfcc=n_mfcc)

      #4 calculo del vector
      mfcc_mean = np.mean(audio_matriz, axis=1)  # Promedio de cada coeficiente a lo largo del tiempo

    else:
      datos_recortados = path_audio
      #tiempo_recortado = np.linspace(0,len(datos_recortados)/fs,num=len(datos_recortados))
      #x_norm_recortado = (datos_recortados-np.mean(datos_recortados))/float(np.max(np.abs(datos_recortados)))

      # 1. Ventaneo y FFT
      mel_spectrogram = librosa.feature.melspectrogram(
          y=datos_recortados, sr=sr, n_fft=n_fft, hop_length=hop_length, n_mels=n_mels,window='hann')

      # 2. Escala logarítmica (dB)
      log_mel_spectrogram = librosa.power_to_db(mel_spectrogram, ref=np.max)

      # 3. Cálculo de MFCCs
      audio_matriz = librosa.feature.mfcc(S=log_mel_spectrogram, sr=sr, n_mfcc=n_mfcc)

      #4 calculo del vector
      mfcc_mean = np.mean(audio_matriz, axis=1)  # Promedio de cada coeficiente a lo largo del tiempo

    return mfcc_mean

def similarity_vectors(mfcc1_mean, mfcc2_mean):

    #Comparativa ( con distancia Euclidiana)
    distance = euclidean(mfcc1_mean, mfcc2_mean)
    correlation, _ = pearsonr(mfcc1_mean, mfcc2_mean)

    return distance

def add_noise_to_audio(audio, sr, snr_db):
    """
    Añade ruido blanco a un audio según un valor de SNR (Relación Señal a Ruido).

    Args:
    - audio: ndarray, señal de audio.
    - sr: int, frecuencia de muestreo.
    - snr_db: float, relación señal a ruido en decibeles (SNR).

    Returns:
    - audio_noisy: ndarray, señal de audio con ruido añadido.
    """


    # Calcular la potencia de la señal
    signal_power = np.mean(audio**2)

    # Convertir SNR de dB a escala lineal
    snr_linear = 10**(snr_db / 10)

    # Calcular la potencia del ruido requerida
    noise_power = signal_power / snr_linear

    # Generar ruido blanco con la misma longitud que el audio
    noise = np.random.normal(0, np.sqrt(noise_power), audio.shape)

    # Sumar el ruido al audio
    audio_noisy = audio + noise

    # Calcular la potencia real del ruido generado
    real_noise_power = np.mean(noise**2)

    return audio_noisy

def process_audio_with_noise(file_path, snr_range):
    """
    Procesa un archivo de audio, lo recorta a los primeros 30 segundos y le añade ruido
    en diferentes niveles de SNR.

    Args:
    - file_path: str, ruta del archivo de audio.
    - snr_range: list, lista de valores SNR en dB.

    Returns:
    - results: dict, diccionario con claves como valores de SNR y señales ruidosas.
    """
    """# Cargar el audio
    audio, sr = librosa.load(file_path, sr=None)

    # Recortar a los primeros 30 segundos
    max_samples = int(30 * sr)
    audio = audio[:max_samples]"""

    fs, datos = wavfile.read(file_path)
    duracion_a_recortar = 30  # Duración en segundos
    num_muestras_recortar = int(duracion_a_recortar * fs)
    tiempo = np.linspace(0,len(datos)/fs,num=len(datos))

    datos_recortados = datos[:num_muestras_recortar]
    tiempo_recortado = tiempo[:num_muestras_recortar]
    #Normalizamos el audio en amplitud, que la señal tenga valores entre -1 y 1
    x_norm_recortado = (datos_recortados - np.mean(datos_recortados)) / np.std(datos_recortados)
    canal_izquierdo = x_norm_recortado[:, 0]

    results = {}

    # Añadir ruido a diferentes valores de SNR
    for snr_db in snr_range:
        noisy_audio = add_noise_to_audio(canal_izquierdo, sr, snr_db)
        results[snr_db] = noisy_audio

    return results, sr


def construir_matriz_similitud(diccionario_ruidosos, mfccs_list):
    """
    Construye una matriz de similitud para una canción con diferentes niveles de SNR.

    Args:
    - diccionario_ruidosos: Diccionario con claves de SNR y señales ruidosas como valores.
    """
    n_snr = len(snr_range)
    matriz_similitud = np.zeros((10, n_snr))  # Inicializar matriz

    # Convertir cada audio ruidoso en su vector de características
    vectores = {snr: generar_audio_vector(diccionario_ruidosos[snr]) for snr in snr_range}

    # Calcular similitudes entre todos los pares de SNR
    for i in range(10):
        for j, snr2 in enumerate(snr_range):
            matriz_similitud[i, j] = similarity_vectors(mfccs_list[i], vectores[snr2])
    return matriz_similitud



def graficar_lineas_similitud(matriz_similitud, snr_range, titulo):
    """
    Grafica una comparación de similitudes como líneas para cada canción.

    Args:
    - matriz_similitud: Matriz (n_canciones x n_snr) de similitudes.
    - snr_range: Lista de valores de SNR.
    - titulo: Título del gráfico.
    """
    plt.figure(figsize=(10, 6))

    # Graficar cada fila de la matriz como una línea
    for i, similitudes in enumerate(matriz_similitud):
        plt.plot(snr_range, similitudes, label=f'Canción {i + 1}')

    plt.title(titulo)
    plt.xlabel('SNRdB')
    plt.ylabel('Distancia entre vectores')
    plt.legend(title='Canciones', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()  # Asegura que todo el contenido sea visible
    plt.show()

vector1 = generar_audio_vector('metal.wav')
vector2 = generar_audio_vector('metal.wav')
distancia=similarity_vectors(vector1, vector2)
print(distancia)

"""Diseñe una metodolog ́ıa que use bancos de filtros y cálculos de potencia para medir los valores de similitud entre una canción (o segmento) de entrada y las 10 canciones de la BD construida en (1).


"""

canciones =['alternativa.wav', 'clasica.wav', 'electronica.wav', 'flamenco.wav', 'metal.wav', 'rap.wav','regueton.wav',
            'rock.wav','salsa.wav','tango.wav']

mfccs_list = []
for archivo in canciones:
  audio_vector = generar_audio_vector(archivo)
  mfccs_list.append(audio_vector)

# Pedir al usuario el nombre del archivo
ruta_archivo = input("Ingrese el nombre del archivo de audio seguido del .wav: ")

vectorAudio = generar_audio_vector(ruta_archivo)

'''plt.figure(figsize=(10, 6))
librosa.display.specshow(vectorAudio, x_axis='time', sr=sr, hop_length=hop_length, cmap='viridis') #Acá se especifica qué MFCC mostrar
plt.colorbar(format="%+2.0f dB")
plt.title("MFCCs del audio indicado")
plt.xlabel("Tiempo (s)")
plt.ylabel("Coeficientes Cepstrales")
plt.show()'''

j=0
for mfcci in mfccs_list:
  distance = similarity_vectors(vectorAudio, mfcci)
  print('distancia entre ',canciones[j], ' y ', ruta_archivo,': ', distance)
  j+=1

"""3. Considere diferentes niveles de ruido AWGN y súmelos a las 10 canciones de su BD para generar archivos con diferentes valores de relación de señal a ruido así: SNRdB ∈ [−20, −19, . . . , 0]."""

audios_ruidosos=[]
for archivos in canciones:
  # Procesar el audio
  results, sr = process_audio_with_noise(archivos, snr_range)
  audios_ruidosos.append(results)

#display(Audio(audios_ruidosos[0][-10], rate=sr)) # mostrar uno de los audios de la matriz

vector1 = generar_audio_vector('metal.wav')
vector2 = generar_audio_vector(audios_ruidosos[0][0])
distancia=similarity_vectors(vector1, vector2)
print(distancia)
display(Audio(audios_ruidosos[4][0], rate=sr))

"""Para cada canción, construya la matriz de similitud vs. SNRdB y genere diez gráficos (i.e.,para cada matriz) que muestren cómo cambia la similitud de acuerdo con la SNRdB para cada canción."""

# Rango de SNR
snr_range = list(range(-20, 1))

# Iterar sobre todas las canciones
for idx, diccionario_ruidosos in enumerate(audios_ruidosos):
    # Construir la matriz de similitud
    matriz_similitud = construir_matriz_similitud(diccionario_ruidosos,mfccs_list)

    # Graficar la matriz de similitud
    titulo = f'Matriz de Distancia vs SNRdB - Canción {canciones[idx]}'
    graficar_lineas_similitud(matriz_similitud, snr_range, titulo)